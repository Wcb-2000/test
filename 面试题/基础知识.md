### 原型和原型链
* 原型：原型分为显式原型和隐式原型，每个对象都有隐式原型对象，它指向自己的构造函数的显式原型；主要实现继承关系。
* 原型链：多个__proto__组成的集合称为原型链
  ·所有实例的__proto__都指向他们构造函数的prototype
  ·所有的prototype都是对象，自然它的__proto__指向的是Object()的prototype
  ·所有的构造函数的隐式原型指向的都是Function()的显示原型
  ·Object的隐式原型是null

### 作用域和作用域链
* 作用域：规定变量和函数的可使用范围为作用域
* 作用域链：当查找一个变量或函数需要从局部到全局依次查找的过程，不同的作用域的集合称作作用域链

### 宏任务和微任务
* 宏任务：script、setTimeOut、setInterval、setImmediate
* 微任务：promise.then,process.nextTick、Object.observe、MutationObserver
#### 宏任务和微任务如何执行
* 执行的时候有两个队列分别存放宏任务和微任务
* 当执行第一个宏任务的时候，将微任务都放入队列中
* 第一个宏任务执行完，清空微任务队列
* 再取一个宏任务，执行，再清空队列
* 依次循环

### 什么是变量提升
* 变量在声明前可以进行调用，调用结果为undefined
### var let const 的区别
* var:  1.声明的变量可以变量提升，let和const不能
        2.可以重复声明
        3.在非函数作用域中声明，是挂在到window上

* let:  1.let声明的变量只在局部起作用
        2.let防止变量污染
        3.不可重复声明

* const：1.具有let的所有特征
        2.不可被改变
        3.如果声明的数组或对象，内容可以改变

### 箭头函数和普通函数的区别？箭头函数可以当作构造函数new吗?
  箭头函数是普通函数的简写，但是它不具备很多普通函数的特性
  区别：
  * this指向问题：箭头函数的this指向它定义时所在的对象，而不是调用时所在的对象
  * 不会函数提升
  * 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
  * 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
  * 不可以使用yield命令，因此箭头函数不能用作Generator函数。
  * 不能调用call和apply：没有自己的this

### 内存泄露、垃圾回收机制
* 什么是内存泄漏：内存泄露是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏；
* 为什么会：内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对  象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃

* 垃圾回收机制
  * 1.标记清楚法：
      垃圾回收机制获取根并标记他们，然后访问并标记所有来自它们的引用，然后在访问这些对象并标记它们的引用…如此递进结束后若发现有没有标记的（不可达的）进行删除，进入执行环境的不能进行删除

  * 2.引用计数法：
      声明一个变量并给该变量赋值一个引用类型的值时候，该值的计数+1，当该值赋值给另一个变量的时候，该计数+1，当该值被其他值取代的时候，该计数-1，当计数变为0的时候，说明无法访问该值了，垃圾回收机制清除该对象

### 闭包
* 什么是闭包：函数执行，形成私有的执行上下文，使内部私有变量不受外界干扰，起到保护和保存的作用
* 闭包3个特点：1.函数嵌套函数； 2.函数内部可以引用函数外部的参数和变量；  3.参数和变量不会被垃圾回收机制回收
* 应用场景： 1.设计模式中的单例模式
            2.for循环中的保留i的操作
            3.防抖和节流
            4.函数柯里化
* 缺点： 会造成内存泄漏

### 手写call()、apply()、bind() --改变this指向
* call和apply实现思路主要是：
        ·判断是否是函数调用，若非函数调用抛异常
        ·通过新对象（context）来调用函数
                ·给context创建一个fn设置为需要调用的函数
                ·结束调用完之后删除fn
* bind实现思路
        ·判断是否是函数调用，若非函数调用抛异常
        ·返回函数
                ·判断函数的调用方式，是否是被new出来的
                        ·new出来的话返回空对象，但是实例的__proto__指向_this的prototype
* 完成函数柯里化
        ·Array.prototype.slice.call()
### 测试代码执行时间
* console.time('a')  执行代码  console.timeEnd('a')
### JS常用的继承方式
* 原型继承\组合继承\寄生组合继承\ES6的extend   
  * 原型继承:把父类的实例作为子类的原型
  * 缺点:子类的实例共享了父类构造函数的引用属性  不能传参

### 手写浅拷贝、深拷贝
* 浅拷贝：只复制对象属性，引用对象的地址。修改一个对象属性影响全部对象
* 深拷贝：不仅复制对象属性或元素本身，还负责了指向的对象，全新互不影响

#### 浅拷贝方法
  * 1.Es6，扩展运算符
  * 2.Es5，构造一个容器存放对象

#### 深拷贝方法
  * 解决问题：循环引用问题、函数丢失问题
  * 方法一：JSON转换
  * 方法二：递归拷贝（解决函数丢失问题，循环没有解决）
  * 方法三：引入键值对
### 同源策略和跨域
  * 同源：协议、域名、端口号一致
  * 无视同源策略：加载图片、css、js
    * <img src=跨域的图片地址>
    * <link href=跨域的css地址> 
    * <script src=跨域的js地址>
  * 跨域：所以的跨域，都必须经过server端允许和配合，未经server端就实现跨域，说明浏览器存在漏洞，
  * 跨域方法：jsonp和cors(服务端)
    * JSONP：利用script标签实现跨域数据的访问。
    script标签引入JavaScript的文件脚本并调用其中的数据方法。
    * 在http的头部header加入扩展字段，允许此域
### CDN
  * 内容分发网络，类似一个分布式存储站，共享资源，提升访问速度

### 节流防抖概念以及应用场景
  * 节流：控制执行频率，n秒内只运行一次，若在n秒内触发多次，也只有一次生效。
  * 应用场景：DOM元素拖拽功能mouseMove、窗口滚动scroll、窗口调整resize、抢购疯狂点击click
  
  * 防抖：设置n秒后触发事件，n妙内若重新触发，则重新计时。
  * 应用场景：账户密码输入、搜索关键词
### 数组去重方法
  * 方法一：利用forEach()和indexOf()
  * 说明：本质是双重遍历，效率差一点

  * 方法二：利用forEach() + 对象容器
  * 说明： 只需遍历一次，效率高

  * 方法三：ES6语法 扩展运算符...
### 数组排序方法
  * 五种：sort()方法、选择排序、冒泡排序、插入排序、快速排序
  * sort():增加判定条件
  * 选择排序：先选择一个元素放在初始位置，之后将剩余数组与之对比，互换位置
  * 冒泡排序：一次比较两个相邻的数，如果不符合规则互换位置，一次比较就能够将最大或最小的值放在数组最后一位继续对除【最后一位】之外的所有元素重复上述过程
  * 插入排序：将数组第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
                  从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。
                                                  如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。
  * 快速排列：在已知数据集合中随便去一个基准(pivot)
                  将其余数据以基准为中心，大于分放右边，小于的放左边
                  将左右两个子集重复以上两个步骤
### 数组扁平化方法 flatten(arr)
  * 说明：多维数组变为一维数组 并输出新数组
  * 方法一：ES5，利用forEach()
  * 方法二：ES6的some()语法

### 类型判断的方法有哪些
  * typeof
    * 缺点：typeof null 的值为Object  
  * instanceof
    * 缺点：只能判断对象是否存在于目标对象的原型链上，单纯字面量不能判断
  * constructor
  * Object.prototype.toString.call()
    * 缺点：不能细分为谁的实例
### 各种类选择器权重
  * 1.!important
  * 2.内联样式  如style=""
  * 3.id选择器  如#id
  * 4.类选择器=属性选择器=伪类选择器    如.class
  * 5.标签选择器=伪元素选择器   div p
  * 6.通配符、子选择器、相邻选择器等。  *{} > +

### new 原理
  
## 计算机基础 https://juejin.cn/post/6844904100035821575
  ### http协议有哪些请求方法
  * GET: 通常用来获取资源
  * HEAD: 获取资源的元信息
  * POST: 提交数据，即上传数据
  * PUT: 修改数据
  * DELETE: 删除资源(几乎用不到)
  * CONNECT: 建立连接隧道，用于代理服务器
  * OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
  * TRACE: 追踪请求-响应的传输路径

  ### GET和POST的区别
  * 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
  * 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
  * 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
  * 从幂等性的角度，GET是幂等的，而POST不是。(每次请求结果可能不同，幂等表示副作用相同)
  * 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)
  * 
  ### http（默认端口80） 与 https（默认端口443）的区别
  * 安全上：https 是 使用 TLS/SSL加密的 HTTP协议
  * 申请上：https需要使用ca申请证书
  * 传输上：http是超文本传输，明文传输；https是具有安全性的ssl加密传输协议
  * 端口：http默认是80；https是443

  ### SSL/TSL
  * 说明：SSL是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”，其出现就是为了解决HTTP传输不安全的问题；到了1999年，SSL被标准化，标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”，所以这两者其实就是同一种协议，只不过是在不同阶段的不同称呼。
  
  * SSL提供的服务/作用：
    1. 认证用户和服务器，确保数据发送到正确的客户端和服务器；
    2. 加密数据以防止数据中途被窃取；
    3. 维护数据的完整性，确保数据在传输过程中不被改变。
   
  * 加密：对称加密、非对称加密、混合加密
  
  ### 从输入url到页面加载过程
  （DNS 解析过程，HTML词法分析和语法分析，CSS解析， 合成图层、合成线程调用光栅化线程池，生成位图后浏览器进程间通信过程，显卡缓存与显示器的关系）

![image-20210626115051548](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210626115051548.png)

* 过程：
​    首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户

1. DNS 解析
2. TCP 连接
3. HTTP 请求抛出
4. 服务端处理请求，HTTP 响应返回
5. 浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户


  ### 常见状态码
  * 1xx: 表示目前是协议处理的中间状态，还需要后续操作。
  * 2xx: 表示成功状态。
  * 3xx: 重定向状态，资源位置发生变动，需要重新请求。
  * 4xx: 客户端请求报文有误。
  * 5xx: 服务器端发生错误。

  ### 三次握手和四次挥手
  * 

  ### CSRF和XSS攻击
  ### Last-Modified 和 Etag 有什么区别？
  ### 浏览器缓存 强缓存、协商缓存
## Vuejs 知识点梳理
  * vue生命周期
  * 组件通信
  * vuex介绍
  * diff

## webpack 知识点

## 前端前沿的方向
  * flutter，dart，serverless、WebAssembly、PWA