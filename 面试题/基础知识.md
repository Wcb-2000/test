### 原型和原型链
* 原型：原型分为显式原型和隐式原型，每个对象都有隐式原型对象，它指向自己的构造函数的显式原型；主要实现继承关系。
* 原型链：多个__proto__组成的集合称为原型链
  ·所有实例的__proto__都指向他们构造函数的prototype
  ·所有的prototype都是对象，自然它的__proto__指向的是Object()的prototype
  ·所有的构造函数的隐式原型指向的都是Function()的显示原型
  ·Object的隐式原型是null

### 作用域和作用域链
* 作用域：规定变量和函数的可使用范围为作用域
* 作用域链：当查找一个变量或函数需要从局部到全局依次查找的过程，不同的作用域的集合称作作用域链

### 宏任务和微任务
* 宏任务：script、setTimeOut、setInterval、setImmediate
* 微任务：promise.then,process.nextTick、Object.observe、MutationObserver
#### 宏任务和微任务如何执行
* 执行的时候有两个队列分别存放宏任务和微任务
* 当执行第一个宏任务的时候，将微任务都放入队列中
* 第一个宏任务执行完，清空微任务队列
* 再取一个宏任务，执行，再清空队列
* 依次循环

### 什么是变量提升
* 变量在声明前可以进行调用，调用结果为undefined
  
### var let const 的区别
* var:  1.声明的变量可以变量提升，let和const不能
        2.可以重复声明
        3.在非函数作用域中声明，是挂在到window上

* let:  1.let声明的变量只在局部起作用
        2.let防止变量污染
        3.不可重复声明

* const：1.具有let的所有特征
        2.不可被改变
        3.如果声明的数组或对象，内容可以改变

### 箭头函数和普通函数的区别？箭头函数可以当作构造函数new吗?
  箭头函数是普通函数的简写，但是它不具备很多普通函数的特性
  区别：
  * this指向问题：箭头函数的this指向它定义时所在的对象，而不是调用时所在的对象
  * 不会函数提升
  * 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
  * 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
  * 不可以使用yield命令，因此箭头函数不能用作Generator函数。
  * 不能调用call和apply：没有自己的this

### 内存泄露、垃圾回收机制
* 什么是内存泄漏：内存泄露是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏；
* 为什么会：内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对  象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃

* 垃圾回收机制
  * 1.标记清楚法：
      垃圾回收机制获取根并标记他们，然后访问并标记所有来自它们的引用，然后在访问这些对象并标记它们的引用…如此递进结束后若发现有没有标记的（不可达的）进行删除，进入执行环境的不能进行删除

  * 2.引用计数法：
      声明一个变量并给该变量赋值一个引用类型的值时候，该值的计数+1，当该值赋值给另一个变量的时候，该计数+1，当该值被其他值取代的时候，该计数-1，当计数变为0的时候，说明无法访问该值了，垃圾回收机制清除该对象

### 闭包
* 什么是闭包：函数执行，形成私有的执行上下文，使内部私有变量不受外界干扰，起到保护和保存的作用
* 闭包3个特点：1.函数嵌套函数； 2.函数内部可以引用函数外部的参数和变量；  3.参数和变量不会被垃圾回收机制回收
* 应用场景： 1.设计模式中的单例模式
            2.for循环中的保留i的操作
            3.防抖和节流
            4.函数柯里化
* 缺点： 会造成内存泄漏

### 手写call()、apply()、bind()

### 测试代码执行时间
* console.time('a')  执行代码  console.timeEnd('a')