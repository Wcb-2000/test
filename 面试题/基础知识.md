### 原型和原型链
* 原型：原型分为显式原型和隐式原型，每个对象都有隐式原型对象，它指向自己的构造函数的显式原型；主要实现继承关系。
* 原型链：多个__proto__组成的集合称为原型链
  ·所有实例的__proto__都指向他们构造函数的prototype
  ·所有的prototype都是对象，自然它的__proto__指向的是Object()的prototype
  ·所有的构造函数的隐式原型指向的都是Function()的显示原型
  ·Object的隐式原型是null

### instanceof原理
* 含义:判断一个对象是否属于另一个对象的实例
* 原理:通过原型链查找进行判断
### 作用域和作用域链
* 作用域：规定变量和函数的可使用范围为作用域
* 作用域链：当查找一个变量或函数需要从局部到全局依次查找的过程，不同的作用域的集合称作作用域链

### 闭包
* 什么是闭包：函数执行，形成私有的执行上下文，使内部私有变量不受外界干扰，起到保护和保存的作用
* 闭包3个特点：1.函数嵌套函数； 2.函数内部可以引用函数外部的参数和变量；  3.参数和变量不会被垃圾回收机制回收
* 自由变量的查找，是在函数定义的地方，向上级作用域查找，而并不是在执行的地方
* 应用场景： 1.设计模式中的单例模式
            2.for循环中的保留i的操作
            3.防抖和节流
            4.函数柯里化
* 缺点： 会造成内存泄漏

### 内存泄露、垃圾回收机制
* 什么是内存泄漏：内存泄露是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏；
* 为什么会：内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对  象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃

* 垃圾回收机制
  * 1.标记清楚法：
      垃圾回收机制获取根并标记他们，然后访问并标记所有来自它们的引用，然后在访问这些对象并标记它们的引用…如此递进结束后若发现有没有标记的（不可达的）进行删除，进入执行环境的不能进行删除

  * 2.引用计数法：
      声明一个变量并给该变量赋值一个引用类型的值时候，该值的计数+1，当该值赋值给另一个变量的时候，该计数+1，当该值被其他值取代的时候，该计数-1，当计数变为0的时候，说明无法访问该值了，垃圾回收机制清除该对象

### 宏任务和微任务
* 宏任务：script、setTimeOut、setInterval、setImmediate
* 微任务：promise.then,process.nextTick、Object.observe、MutationObserver
#### 宏任务和微任务如何执行
* 执行的时候有两个队列分别存放宏任务和微任务
* 当执行第一个宏任务的时候，将微任务都放入队列中
* 第一个宏任务执行完，清空微任务队列
* 再取一个宏任务，执行，再清空队列
* 依次循环

### 什么是变量提升
* 变量在声明前可以进行调用，调用结果为undefined

### ES6新增有哪些
let(声明变量)
const(声明常量,常量不能修改的量)
var、let、const的区别
1. let和const声明变量不存在变量提升，如果要使用这个变量，我们需要在变量定义之后使用;
2. let和const不能重复声明变量，如果重复声明会报错;
3. 用let 和 const 在全局声明变量不会给window增加属性;
4. let和const出现在代码块中，会把代码块(字面量声明对象除外)变成块级作用域,并且出现暂时 性死区 class(创建类)
import/export(基于ES6的模块规范创建导入/导出模块(文件/组件))
new set(数组去重)
Symbol(唯一的值) ** var a = Symbol(‘qqq’)
…ary(展开运算符、剩余运算符)
${} 模板字符串 **
解构赋值 let {a} = obj; let [b] = ary
for of 循环
()=>{} 箭头函数
箭头函数与普通函数的区别：
1. 箭头函数是匿名函数，不能作为构造函数，不能使用new
2. 箭头函数没有原型属性
3.this指向不同，箭头函数的this是定义时所在的对象，普通函数看前面有没有.,点前面是谁this 就是谁,没有.就是window
4. 不可以使用arguments对象，该对象在函数体内不存在。
数组新增方法：**some every filter reduce …
对象新增方法： Object.assign() Object.keys() Object.values() Object.entries()/Object.fromEntries
Object.create() 
Object.setPrototypeOf()/Object.getPrototypeOf()…
### var let const 的区别
* var:  1.声明的变量可以变量提升，let和const不能
        2.可以重复声明
        3.在非函数作用域中声明，是挂在到window上

* let:  1.let声明的变量只在局部起作用
        2.let防止变量污染
        3.不可重复声明

* const：1.具有let的所有特征
        2.不可被改变
        3.如果声明的数组或对象，内容可以改变

### 箭头函数和普通函数的区别？箭头函数可以当作构造函数new吗?
  箭头函数是普通函数的简写，但是它不具备很多普通函数的特性
  区别：
  * this指向问题：箭头函数的this指向它定义时所在的对象，而不是调用时所在的对象
  * 不会函数提升
  * 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
  * 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
  * 不可以使用yield命令，因此箭头函数不能用作Generator函数。
  * 不能调用call和apply：没有自己的this

### forEach(item,index,arr => {})和map(item,index,arr => {})方法的区别 
* 相同点：遍历数组的每一项
* 不同点：forEach()没有返回值,对原数组改变；  map有返回值，可以return出来，并且可以返回新数组
### 手写call()、apply()、bind() --改变this指向
* call和apply实现思路主要是：
        ·判断是否是函数调用，若非函数调用抛异常
        ·通过新对象（context）来调用函数
                ·给context创建一个fn设置为需要调用的函数
                ·结束调用完之后删除fn
* bind实现思路
        ·判断是否是函数调用，若非函数调用抛异常
        ·返回函数
                ·判断函数的调用方式，是否是被new出来的
                        ·new出来的话返回空对象，但是实例的__proto__指向_this的prototype
* 完成函数柯里化
        ·Array.prototype.slice.call()
### 测试代码执行时间
* console.time('a')  执行代码  console.timeEnd('a')
### JS常用的继承方式
* 原型继承\组合继承\寄生组合继承\ES6的extend   
  * 原型继承:把父类的实例作为子类的原型
  * 缺点:子类的实例共享了父类构造函数的引用属性  不能传参

### 手写浅拷贝、深拷贝
* 浅拷贝：只复制对象属性，引用对象的地址。修改一个对象属性影响全部对象
* 深拷贝：不仅复制对象属性或元素本身，还负责了指向的对象，全新互不影响

#### 浅拷贝方法
  * 1.Es6，扩展运算符
  * 2.Es5，构造一个容器存放对象

#### 深拷贝方法
  * 解决问题：循环引用问题、函数丢失问题
  * 方法一：JSON转换
  * 方法二：递归拷贝（解决函数丢失问题，循环没有解决）
  * 方法三：引入键值对
### 同源策略和跨域
  * 同源：协议、域名、端口号一致
  * 无视同源策略：加载图片、css、js
    * <img src=跨域的图片地址>
    * <link href=跨域的css地址> 
    * <script src=跨域的js地址>
  * 跨域：所有的跨域，都必须经过server端允许和配合，未经server端就实现跨域，说明浏览器存在漏洞，
  * 跨域方法：jsonp和cors(服务端)
    * JSONP：利用script标签实现跨域数据的访问。
    script标签引入JavaScript的文件脚本并调用其中的数据方法。
    * 在http的头部header加入扩展字段，允许此域
### CDN
  * 内容分发网络，类似一个分布式存储站，共享资源，提升访问速度

### 节流防抖概念以及应用场景
  * 节流：控制执行频率，n秒内只运行一次，若在n秒内触发多次，也只有一次生效。
  * 应用场景：DOM元素拖拽功能mouseMove、窗口滚动scroll、窗口调整resize、抢购疯狂点击click
  
  * 防抖：设置n秒后触发事件，n妙内若重新触发，则重新计时。
  * 应用场景：账户密码输入、搜索关键词
### 数组去重方法
  * 方法一：利用forEach()和indexOf()
  * 说明：本质是双重遍历，效率差一点

  * 方法二：利用forEach() + 对象容器
  * 说明： 只需遍历一次，效率高

  * 方法三：ES6语法 扩展运算符...
### 数组排序方法
  * 五种：sort()方法、选择排序、冒泡排序、插入排序、快速排序
  * sort():增加判定条件
  * 选择排序：先选择一个元素放在初始位置，之后将剩余数组与之对比，互换位置
  * 冒泡排序：一次比较两个相邻的数，如果不符合规则互换位置，一次比较就能够将最大或最小的值放在数组最后一位继续对除【最后一位】之外的所有元素重复上述过程
  * 插入排序：将数组第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
                  从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。
                                                  如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。
  * 快速排列：在已知数据集合中随便去一个基准(pivot)
                  将其余数据以基准为中心，大于分放右边，小于的放左边
                  将左右两个子集重复以上两个步骤
  
### 数组扁平化方法 flatten(arr)
  * 说明：多维数组变为一维数组 并输出新数组
  * 方法一：ES5，利用forEach()
  * 方法二：ES6的some()语法

### 类型判断的方法有哪些
  * typeof
    * 缺点：typeof null 的值为Object  
  * instanceof
    * 缺点：只能判断对象是否存在于目标对象的原型链上，单纯字面量不能判断
  * constructor
  * Object.prototype.toString.call()
    * 缺点：不能细分为谁的实例
### 各种类选择器权重
  * 1.!important
  * 2.内联样式  如style=""
  * 3.id选择器  如#id
  * 4.类选择器=属性选择器=伪类选择器    如.class
  * 5.标签选择器=伪元素选择器   div p
  * 6.通配符、子选择器、相邻选择器等。  *{} > +

### new 原理
  
## 计算机基础 https://juejin.cn/post/6844904100035821575
  ### http协议有哪些请求方法
  * GET: 通常用来获取资源
  * HEAD: 获取资源的元信息
  * POST: 提交数据，即上传数据
  * PUT: 修改数据
  * DELETE: 删除资源(几乎用不到)
  * CONNECT: 建立连接隧道，用于代理服务器
  * OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
  * TRACE: 追踪请求-响应的传输路径

  ### GET和POST的区别
  * 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
  * 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
  * 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
  * 从幂等性的角度，GET是幂等的，而POST不是。(每次请求结果可能不同，幂等表示副作用相同)
  * 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)
  * 
  ### http（默认端口80） 与 https（默认端口443）的区别
  * 安全上：https 是 使用 TLS/SSL加密的 HTTP协议
  * 申请上：https需要使用ca申请证书
  * 传输上：http是超文本传输，明文传输；https是具有安全性的ssl加密传输协议
  * 端口：http默认是80；https是443

  ### SSL/TSL
  * 说明：SSL是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”，其出现就是为了解决HTTP传输不安全的问题；到了1999年，SSL被标准化，标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”，所以这两者其实就是同一种协议，只不过是在不同阶段的不同称呼。
  
  * SSL提供的服务/作用：
    1. 认证用户和服务器，确保数据发送到正确的客户端和服务器；
    2. 加密数据以防止数据中途被窃取；
    3. 维护数据的完整性，确保数据在传输过程中不被改变。
   
  * 加密：对称加密、非对称加密、混合加密
  
  ### 从输入url到页面加载过程
  （DNS 解析过程，HTML词法分析和语法分析，CSS解析， 合成图层、合成线程调用光栅化线程池，生成位图后浏览器进程间通信过程，显卡缓存与显示器的关系）

![image-20210626115051548](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210626115051548.png)

* 过程：
​    首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户

1. DNS 解析
2. TCP 连接
3. HTTP 请求抛出
4. 服务端处理请求，HTTP 响应返回
5. 浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户


  ### 常见状态码
  * 1xx: 表示目前是协议处理的中间状态，还需要后续操作。
  * 2xx: 表示成功状态。
  * 3xx: 重定向状态，资源位置发生变动，需要重新请求。
  * 4xx: 客户端请求报文有误。
  * 5xx: 服务器端发生错误。

  ### 三次握手和四次挥手
  * 

  ### CSRF和XSS攻击
  ### Last-Modified 和 Etag 有什么区别？
  ### 浏览器缓存 强缓存、协商缓存
## Vuejs 知识点梳理
  * vue生命周期
  ### 计算属性computed和侦听器watch的区别
  * 共同点：都是根据依赖变化从而发生变化，都自带缓存，数据没改变直接调用
  * 不同点：计算属性中，返回的是一个data中没有的值（新值）并且必须包含return，
侦听器中，变化的值是data中存在的值，并且不包含return，在侦听器中可以执行异步操作，并控制操作的频率，这些都是计算属性无法做到的

(1).计算属性的应用场景是计算的内容需要依赖多个属性的情况
侦听器的应用场景是计算的内容依赖一个属性的情况
(2).计算属性缓存结果时每次都会重新创建变量
而侦听器是直接计算，不会创建变量保存结果
也就意味着，数据如果会反复的发生变化，计算很多次的情况下，计算属性的开销将会更大，也就意味着这种情况不适合使用计算属性，适合使用侦听器
那么，如果一个数据反复会被使用，但是它计算依赖的内容很少发生变化的情况下，计算属性会缓存结果，就更加适合这种情况。
(3).computed的结果是通过return返回的，而watch不需要return。
(4).watch中的参数可以得到侦听属性改变的最新结果，而computed函数没有这种参数。

补充：
watch只会监听数据的值是否发生改变，而不会监听地址的变化，如果需要监听引用类型的数据变化，需要深度监听：obj:{handler(newVal){},deep:true}------用handler+deep的方式进行深度监听。
在特殊的情况下(更改数组中的数据时，数组已经更改，但是视图没有更新)，watch无法监听数组的变化,更改数组必须要用splice()或者$set。

结论：
我们在计算开销比较大(计算次数多或者异步处理)的时候，会使用侦听器watch来得到计算结果。
而其他情况建议使用计算属性computed，因为缓存节省多次计算的性能。
  * 应用场景：computed,数据计算和字符处理，购物车价格、名字拼接
  * 应用场景：watch，监听数值（条件），弹框提醒，一个数据触发多个事件

  ### v-show和v-if的区别



  ### 组件通信
  
  * vuex介绍
  * diff
  * 

## webpack 知识点
  * loader和plugin
## 前端前沿的方向
  * flutter，dart，serverless、WebAssembly、PWA

自我介绍
项目经历和难点
前端模块化
数组排序方法
哪个时间更快
作用域、原型、原型的this指向谁，指向构造函数的
闭包的理解  
数据类型有哪些  
类型判断
ES6新增、let的区别
原生js类似Date这样的有哪些
数组中插入的方法
js触发事件有哪些
html标签有哪些
选择器有哪些
http协议
浏览器缓存
webpack和babel
export和import的区别
vue生命周期
vuex的组件间传递
vue的基本命令
vue路由  hash和history 没答
vue源码

反问

自我介绍，如果是技术，要偏向项目
v-if和v-show的区别，简单说
路由传值的方式  没答出来
组件创建方式1.注册组件、2.导入组件
介绍vuex 有哪些属性
vuex异步action部分 如何触发 --commit
vue中的key值得意义
垂直居中水平居中
es6 有哪些
var let const差别  
为什么const 的对象或数组的值可能改变
两数组的差值  indexOf included

反问

自我介绍
vue3新增的东西
vue2-vue3双向绑定的原理变化
* object.defineProperty --> proxy
变化后有什么优点
后端接口数据处理
项目小程序购物车如何实现
如何学习，有参加培训机构吗


领星

自我介绍
学习前端得一个路线
为什么学习前端
数据类型有哪些
原型和原型链
url解析过程
说说深拷贝和浅拷贝
说说防抖和节流
说说闭包
call(),apply(),bind()得用处和方法     没答好
es6方法                    没答全
var let const 的差别
const数组对象内容为什么可以改变
浏览器缓存机制
数组有哪些方法          没答全
es6新增数组的方法
垂直水平居中
样式选择器
块级元素和行内元素的区别
forEach和map方法的区别      不会

vue方面
vue得生命周期
在哪个阶段导入数据
在哪个阶段获取dom
解释单向数据流和双向数据绑定
keep-alive是什么
vue中data为什么必须是函数
vuex的属性及各个用处
组件之间传值                没答全
nextTick用过吗，是什么
双向绑定原理                答得太笼统
如何让一个骰子的六点设置为百分之50


vue中data数组重新赋值，如何获取
vue中data嵌套数组的值，如何获取
keep-alive 的传值

vue的生命周期各个阶段内容
新老版本交替的时候，用户如何更新数据而不是使用老的缓存

